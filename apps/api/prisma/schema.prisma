generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id         BigInt   @id
  username   String?  @db.VarChar(255)
  firstName  String   @db.VarChar(255)
  RoomPlayer RoomPlayer[]
  UserMeta   UserMeta?
  BillingPurchase BillingPurchase[]
}

model Room {
  id         String       @id @default(uuid())
  createdAt  DateTime     @default(now())
  RoomPlayer RoomPlayer[]
  // Solo mode flags
  solo       Boolean      @default(false)
  botCount   Int          @default(0)
  BotInstance BotInstance[]
  sessions   RoomSession[]
}

model RoomPlayer {
  roomId   String
  userId   BigInt
  joinedAt DateTime @default(now())

  Room Room @relation(fields: [roomId], references: [id])
  User User @relation(fields: [userId], references: [id])

  @@id([roomId, userId])
}

// New: Question and types
enum QuestionType {
  text
  word
}

model Category {
  id        String     @id @default(uuid())
  createdAt DateTime   @default(now())
  title     String     @db.VarChar(255) @unique
  tags      String[]
  questions Question[]
  superCells RoomSuperCell[]
}

model Question {
  id               String       @id @default(uuid())
  createdAt        DateTime     @default(now())
  type             QuestionType
  prompt           String       @db.Text
  rawAnswer        String       @db.Text
  canonicalAnswer  String       @db.Text
  // New fields for gameplay and metadata
  value            Int           @default(0)
  answersAccept    String[]      @default([])
  answersReject    String[]      @default([])
  requireFull      Boolean       @default(false)
  language         String?       @db.VarChar(10)
  hint             String?       @db.Text
  // Relation to Category
  categoryId       String?
  Category         Category?     @relation(fields: [categoryId], references: [id])
  SuperQuestions   SuperQuestion[]

  @@index([categoryId])
  @@index([categoryId, value])
}

// New: BillingPurchase and UserMeta
enum BillingStatus {
  paid
  refunded
}

enum BillingType {
  hint_letter
}

model BillingPurchase {
  id              String        @id @default(uuid())
  createdAt       DateTime      @default(now())
  userId          BigInt
  type            BillingType
  qty             Int
  status          BillingStatus @default(paid)
  tgPaymentId     String        @db.Text

  User User @relation(fields: [userId], references: [id])

  @@index([userId])
}

model UserMeta {
  id            String   @id @default(uuid())
  userId        BigInt   @unique
  hintAllowance Int      @default(0)
  profileScore  Int      @default(0)
  achievements  Json?

  User User @relation(fields: [userId], references: [id])
}

// Track which bot profiles were used in a solo match (optional)
model BotInstance {
  id          String   @id @default(uuid())
  roomId      String
  profileCode String   @db.VarChar(50)
  seededAt    DateTime @default(now())

  Room Room @relation(fields: [roomId], references: [id])

  @@index([roomId])
}

// --- SuperQuestion & Session Models ---
enum RoomSessionStatus {
  active
  completed
}

model SuperQuestion {
  id           String   @id @default(uuid())
  createdAt    DateTime @default(now())

  // Link to base Question; category/value derived from Question
  questionId   String
  Question     Question  @relation(fields: [questionId], references: [id])

  enabled      Boolean  @default(true)

  // Options payload and correct index
  options      Json     // JSON array of options
  correctIndex Int

  // Optional metadata for rotation and filtering
  locale       String?   @db.VarChar(10)
  tags         String[]
  difficulty   Int?      // 1..5 (optional policy)
  weight       Int?      // for weighted selection
  explanation  String?   @db.Text
  lastUsedAt   DateTime?

  // Audit
  createdBy    BigInt?

  // Backref: assignments within sessions
  SuperCells   RoomSuperCell[]

  @@index([questionId])
}

// Scopes a "game session" across one or more rounds in a room
model RoomSession {
  id         String            @id @default(uuid())
  roomId     String
  startedAt  DateTime          @default(now())
  endedAt    DateTime?
  status     RoomSessionStatus @default(active)

  Room       Room              @relation(fields: [roomId], references: [id])
  SuperCells RoomSuperCell[]

  @@index([roomId])
}

// Assignment of a SuperQuestion to a concrete board cell within a session
model RoomSuperCell {
  id              String   @id @default(uuid())
  sessionId       String
  // Optional round reference if rounds are tracked explicitly
  round           Int?
  categoryId      String
  value           Int
  superQuestionId String
  assignedAt      DateTime @default(now())

  Session      RoomSession   @relation(fields: [sessionId], references: [id])
  Category     Category      @relation(fields: [categoryId], references: [id])
  SuperQuestion SuperQuestion @relation(fields: [superQuestionId], references: [id])

  // Nonâ€‘repetition within a session
  @@unique([sessionId, categoryId, value])
  @@unique([sessionId, superQuestionId])

  @@index([sessionId])
  @@index([categoryId, value])
  @@index([superQuestionId])
}
